Project: FIFA 2026 Winner Prediction — Beginner-Friendly Submission
Author: Sahar Karimi
Course: CS 401 — Software Engineering
Date: November 12, 2025

1. Project Overview
- Goal: Produce a beginner-friendly project that predicts the 2026 FIFA World Cup winner using recent international match results (2022–2025). The project emphasizes clarity, reproducibility, and software engineering practices appropriate for a college junior.
- Approach: Use simple, explainable statistics (win counts and win rates) rather than complex ML models to make the core idea easy to present and defend.

2. Learning Objectives & Requirements
- Demonstrate basic data-processing and analysis skills with Python and pandas.
- Show an ability to design a minimal reproducible analysis pipeline (load data, compute metrics, produce results).
- Explain trade-offs and limitations of simple statistical models and small-sample inference.
- Provide deliverables for grading and demonstration: `ML_clean.ipynb`, `recent_wc_matches.csv`, and this `PROJECT_PRESENTATION.txt`. (Note: prediction CSVs may be regenerated by running the notebook.)

3. Data
- Source: Curated set of recent international match results covering 2022 through 2025 saved as `recent_wc_matches.csv`.
- Key columns used: `date`, `home_team`, `away_team`, `home_score`, `away_score`.
- Preprocessing: Minimal — read CSV, treat each row as a match, compute whether the home or away team won. Draws count as non-wins.

4. Method / Algorithm
- Summary: For each team, count (a) total matches played and (b) total wins (home wins + away wins). Compute win rate = (wins / matches) * 100.
- Prediction rule: Pick the team with the highest win rate as the simple prediction for the tournament winner.
- Notes: This is an intentionally naive heuristic chosen for clarity and interpretability. It is not a statistically robust forecasting model for real tournament outcomes.

5. Software Engineering Process
- Requirements: Keep the project runnable with minimal dependencies (Python + pandas). Produce reproducible output files and a readable notebook.
- Design: Single notebook pipeline with 5 clear steps: imports, load data, compute stats, print a prediction, save ranking to CSV.
- Implementation: Code kept simple and modular inside `ML.ipynb`. Minimal external libraries avoid environment complexity for graders.
- Version Control: Project is kept in a git repository (`.git/`) for tracking edits; remove the repo on request for clean submission.
- Testing & Validation: Manual run-through of each notebook cell to verify that outputs are consistent (the notebook was executed to generate `predictions_2026.csv`).
- Reproducibility: Include raw `recent_wc_matches.csv` and `worldcup_predictor_teams.csv` used to compute metrics; the notebook re-runs deterministically on those files.

6. Tools, Languages, Frameworks
- Language: Python 3.11 (notebook-compatible environment).
- Libraries: `pandas` for data loading and manipulation; minimal standard library usage. Matplotlib can be added for plots but is optional.
- Environment: The project originally used a local virtual environment (`.venv/`) to isolate dependencies; the environment can be deleted and recreated from `requirements.txt` if needed.

7. How to Run (for graders / demonstrators)
1. Ensure Python 3.8+ is installed.
2. (Optional) Create and activate a virtual environment:
   - Windows PowerShell:
     python -m venv .venv; .\.venv\Scripts\Activate.ps1
3. Install dependencies (if needed):
   pip install pandas
4. Open `ML_clean.ipynb` in Jupyter Notebook or JupyterLab and run cells in order, or run the contained steps in a Python REPL.
5. The notebook prints a short ranking and, when executed, writes two CSVs to the project folder:
   - `predictions_2026.csv` (filtered ranking used for prediction)
   - `predictions_2026_full.csv` (full unfiltered ranking)
   If these files are missing (deleted), re-running the notebook will regenerate them automatically.

8. Results
- The notebook runs end-to-end and (when run) writes `predictions_2026.csv` and `predictions_2026_full.csv`.
- Example produced output (top-ranked team): Guatemala — 100.0% win rate (from 2 matches). This example highlights the small-sample risk.

9. Limitations & Discussion (important talking points for your presentation)
- Small-sample artifact: Teams with very few matches can exhibit extreme win rates (e.g., 100%) and distort the prediction. This is the primary limitation.
- Simplicity trade-off: The method is explainable but not predictive at scale. More robust methods (Elo ratings, Poisson goal models, or supervised learning on historic features) require more data, feature engineering, and validation.
- Scope: This project was intentionally scoped down to be learnable and presentable for a junior-level course.

10. Recommended Improvements (if you had more time)
- Apply a minimum-match filter before selecting the predicted winner (e.g., ignore teams with < 5 matches).
- Add confidence or uncertainty: show how many matches each top team played and present both filtered and unfiltered lists.
- Replace the naive heuristic with a simple Elo-based ranking or a Poisson goal model, with cross-validation and calibration.
- Add unit tests for small utility functions used in preprocessing and metric calculation.

11. Slide-by-Slide Presentation Script (5–8 minutes total)
- Slide 1 — Title: "FIFA 2026 Winner Prediction — Sahar Karimi". One-line motivation: "Make a beginner-friendly, reproducible prediction using recent match data." (10–15s)
- Slide 2 — Problem & Goal: Explain dataset scope (2022–2025), objective, and why small-scale, interpretable methods were chosen. (30–40s)
- Slide 3 — Data & Preprocessing: Show a sample row from `recent_wc_matches.csv` and describe minimal cleaning. (30s)
- Slide 4 — Method: Explain the win-rate calculation and show the formula. Mention why it's simple and easy to explain. (40s)
- Slide 5 — Demo / Results: Show the notebook output and `predictions_2026.csv`. Point out the top-ranked team and the small-sample caveat. (45–60s)
- Slide 6 — Software Engineering Practices: Briefly cover design choices, reproducibility, version control, and why these practices matter for an engineering course. (30–45s)
- Slide 7 — Limitations & Next Steps: List the sample-size issue and possible upgrades (filtering, Elo, ML). Invite questions about trade-offs. (30–45s)
- Slide 8 — Q&A: Prepared answers for expected questions (see next section). (Remaining time)

12. Q&A — Prepared Answers
- Q: "Why not use machine learning?" A: The course asked for a clear, reproducible submission; a naive method is easier to explain and defend in a short demo. Also, ML requires more data, validation, and time.
- Q: "Is the prediction trustworthy?" A: Not fully — it is illustrative and demonstrates methodology, reproducibility, and awareness of pitfalls. Use filters or larger datasets for serious forecasting.
- Q: "How would you improve it?" A: Add minimum-match thresholds, use Elo ratings or a Poisson goal model, and train simple supervised models with cross-validation.

13. Deliverables (files included in submission)
- `ML_clean.ipynb` — runnable notebook with simple pipeline.
- `recent_wc_matches.csv` — dataset used by the notebook.
- `worldcup_predictor_teams.csv` — team metadata (optional lookup file).
- `README.md` — short instructions to run the notebook and explanation of the approach.
- `PROJECT_SUMMARY.txt` — brief summary for graders.
- `PROJECT_PRESENTATION.txt` — (this file) presentation notes and script.
- Note: `predictions_2026.csv` and `predictions_2026_full.csv` are generated outputs and may be present in the folder; if deleted, re-run `ML_clean.ipynb` to regenerate them.

14. Final Remarks
This project prioritizes pedagogy and reproducibility over predictive accuracy. For a junior-level software engineering assignment, that trade-off is appropriate: the deliverables show clear planning, an implemented pipeline, reproducible output files, and a short presentation script you can use during your demo.

If you'd like, I can:
- Add a minimum-match filter to the notebook and re-run it to produce a filtered prediction.
- Generate a short slide deck (PowerPoint or PDF) using the slide script above.
- Add a brief README section describing the small-sample filter and how to toggle it.

*** End Patch